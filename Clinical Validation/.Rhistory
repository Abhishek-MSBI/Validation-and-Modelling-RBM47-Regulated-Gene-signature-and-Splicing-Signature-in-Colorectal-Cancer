metadata$genotype
gene_id = genes$Gene.ID[ genes$Gene.Name == 'ZEB1' ]
gene_counts = counts[gene_id, ]
gene_counts
gene_data = cbind(metadata, counts=as.numeric(gene_counts))
gene_data
library(ggplot2)
ggplot(gene_data, aes(x = genotype, y = counts, fill = genotype)) + geom_boxplot()
# Download raw counts
counts = read.delim("https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5243/resources/DifferentialSecondaryDataFiles.RnaSeq/raw-counts")
head(counts)
# Download metadata
metadata = read.delim("https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5243/resources/ExperimentDesignFile.RnaSeq/experiment-design")
head(metadata)
# DESeq expects the counts to have gene IDs as row names
head(counts)
rownames(counts) = counts$Gene.ID
head(counts)
# Remove unused columns (gene ID and gene name)
genes = counts[, c("Gene.ID", "Gene.Name")]
counts = counts[, -c(1, 2)]
head(counts)
# DESeq expects the metadata matrix to have sample IDs in the rownames
head(metadata)
rownames(metadata) = metadata$Run
head(metadata)
# Only keep columns of interest
metadata = metadata[, c("Sample.Characteristic.genotype."), drop=FALSE]
# Look at metadata to see how the variables change with respect to each other
metadata
# Rename column
colnames(metadata) = c("genotype")
metadata
# Remove spaces in names to avoid DESeq warnings
metadata$genotype[metadata$genotype == 'wild type genotype'] = 'wildtype'
metadata$genotype[metadata$genotype == 'ZEB1 knockout'] = 'knockout'
metadata
# Turn genotype into a factor
metadata$genotype = factor(metadata$genotype, levels=c("wildtype", "knockout"))
metadata$genotype
gene_id = genes$Gene.ID[ genes$Gene.Name == 'ZEB1' ]
gene_counts = counts[gene_id, ]
gene_counts
gene_data = cbind(metadata, counts=as.numeric(gene_counts))
library(ggplot2)
ggplot(gene_data, aes(x = genotype, y = counts, fill = genotype)) + geom_boxplot()
dds <- DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~genotype)
dds <- DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~genotype)
library(DESeq2)
dds <- DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~genotype)
# Ignore genes with low counts
dds <- dds[rowSums(counts(dds)) > 10, ]
rowSums(counts(dds))
# Ignore genes with low counts
dds <- dds[rowSums(counts(dds)) > 10, ]
# Run DESeq
dds <- DESeq(dds)
# Compare expression
res = results(dds, contrast=c("genotype", "knockout", "wildtype"), alpha=1e-5)
res
# Sidenote: "~" is not a DESeq specific operator
head(iris)
model = lm(Petal.Width ~ Petal.Length, iris)
plot(iris$Petal.Length, iris$Petal.Width)
abline(model)
# Merge gene name into data frame so can compare to GXA UI using gene names
res_df = as.data.frame(res)
head(res_df)
head(genes)
res_df = merge(res_df, genes, by='row.names')
head(res_df)
genes_to_check = c("THY1", "SFMBT2", "PASD1", "SNAI1")
res_df[res_df$Gene.Name %in% genes_to_check, ]
# MA plot
plotMA(res)
# Volcano plot
BiocManager::install('EnhancedVolcano')
genes_to_check = c("DPM1", "TSPAN6", "SCYL3", "FGR")
res_df[res_df$Gene.Name %in% genes_to_check, ]
#Basic arthmetic
2+2
5-3
# Storing a number
gene_length <- 1500
#Storing a piece of text (a 'string' or 'character')
gene_name <- "TP53"
#You can now use the variable names in calculations
gene_length /100
# A numeric vector of geneexpression values
expression_values <- c(10.2, 15.5, 9.8, 20.1, 18.0)
# A character vector of gene IDs
gene_ids <- c("ENSG001", "ENSG002", "ENSG003")
expression_values [1]
gene_ids [3]
expression_values [2:4]
#Display the data frame
print(sample_info)
#creating a data frame for sample information
sample_info <- data.frame(
sample_id = c("SampleA", "SampleB", "SampleC", "SampleD"),
condition = c("Control1", "Control", "Treated", "Treated"),
read_count = c(25000, 56485, 65845, 96485)
)
#Display the data frame
print(sample_info)
#Get the 'Condition' column
sample_info$condition
# You can use square brackets [rows, columns]
sample_info[1,2]
sample_info[ ,3]
sample_info[2, ]
#Create a simple count matrix
#Let's use our gene_id's  and sample_id's fro before
counts <- matrix(
c(150, 200, 50, 65, #Counts for Sample A
160, 210, 15, 25, #Counts for Sample B
800, 950, 15, 25, #Counts for Sample C
820, 980, 12, 30),#Counts for Sample D
nrow = 4, #Number of genes (rows)
byrow =FALSE #Fill the matrix column by column
)
# Assign names to rows and columns for clarity
rownames(counts) <- gene_ids[1:4]
print(counts)
# A character vector of gene IDs
gene_ids <- c("ENSG001", "ENSG002", "ENSG003", "ENSG004")
print(counts)
# A character vector of gene IDs
gene_ids <- c("ENSG001", "ENSG002", "ENSG003", "ENSG004")
expression_values [1] # Returns 10.2
gene_ids [3]
expression_values [2:4]
#creating a data frame for sample information
sample_info <- data.frame(
sample_id = c("SampleA", "SampleB", "SampleC", "SampleD"),
condition = c("Control1", "Control", "Treated", "Treated"),
read_count = c(25000, 56485, 65845, 96485)
)
#Display the data frame
print(sample_info)
#Get the 'Condition' column
sample_info$condition
# You can use square brackets [rows, columns]
sample_info[1,2] #returns value in the 1st row, 2nd column
sample_info[ ,3] # returns the entire 3rd column
sample_info[2, ] # Returns the entire 2nd column
#Create a simple count matrix
#Let's use our gene_id's  and sample_id's fro before
counts <- matrix(
c(150, 200, 50, 65, #Counts for Sample A
160, 210, 15, 25, #Counts for Sample B
800, 950, 15, 25, #Counts for Sample C
820, 980, 12, 30),#Counts for Sample D
nrow = 4, #Number of genes (rows)
byrow =FALSE #Fill the matrix column by column
)
# Assign names to rows and columns for clarity
rownames(counts) <- gene_ids[1:4]
colnames(counts) <- c("SampleA", "SampleB", "SampleC", "SampleD")
print(counts)
#Get the dimensions of our count matrix
dim(counts) #Returns 4 4 (4 rows, 4 columns)
# Get the average read count from our sample_info data frame
mean(sample_info$read_count)
# Get a summary of the data frame
summary(sample_info)
install.packages("dplyr")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
BiocManager::install("DESeq2")
#Install  the whole tidyverse
install.packages("tidyverse")
setwd("C:/Users/abhir/Desktop/RBM47/Clinical Validation")
source("~/.active-rstudio-document")
# --- 2.1: Query for the gene expression data ---
# We'll get Transcriptome Profiling (RNA-Seq)
# GDCquery will find all files that match these criteria
query_coad <- GDCquery(
project = "TCGA-COAD",
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts"
)
# --- 2.2: Download the data ---
# This is the BIG download. It will download all the raw files.
# It may take a very long time (30+ minutes) depending on your internet.
# It will create a "GDCdata" folder in your working directory.
tryCatch({
GDCdownload(
query = query_coad,
method = "api",
files.per.chunk = 100 # Helps with large downloads
)
}, error = function(e) {
message("Download failed, trying with 'client' method...")
GDCdownload(
query = query_coad,
method = "client" # Fallback method
)
})
# --- 2.3: Prepare the data into an R object ---
# This is a crucial step.
# TCGAbiolinks reads all those downloaded files and combines them
# into a single, powerful object: a `SummarizedExperiment`.
# This object contains:
#   1. The count matrix (assay)
#   2. The patient clinical data (colData)
#   3. The gene information (rowData)
# This step also takes a few minutes.
se_coad <- GDCprepare(query = query_coad)
# You can inspect the object:
print(se_coad)
# It will show you the dimensions (genes x patients)
# --- 3.1: Get the clinical data ---
# The clinical data is stored in the 'colData'.
# We can convert it to a standard data.frame.
clinical_df <- as.data.frame(colData(se_coad))
# --- 3.2: Create the survival variables (time and status) ---
# We need two columns:
# 1. 'time': Number of days to death or last follow-up.
# 2. 'status': The event (1 = Dead, 0 = Alive).
# Use 'days_to_death' if patient is dead, otherwise use 'days_to_last_follow_up'
clinical_df$survival_time <- ifelse(
!is.na(clinical_df$days_to_death),
clinical_df$days_to_death,
clinical_df$days_to_last_follow_up
)
# Create the event status
clinical_df$vital_status_numeric <- ifelse(
clinical_df$vital_status == "Dead",
1,
0
)
# --- 3.3: Get the gene expression data ---
# The raw counts are in the 'assay' part of the object.
# Rownames are Ensembl IDs (e.g., ENSG00000...).
count_matrix <- assay(se_coad, "unstranded") # or "tpm_unstranded" if available
# --- 3.4: Normalize and filter for your gene (RBM47) ---
# We can't use raw counts. We'll do a simple log2-transform
# of "counts-per-million" (CPM) for visualization.
# For a more robust analysis, use vst() or voom() as planned for your model.
cpm_matrix <- edgeR::cpm(count_matrix)
if (!require("BiocManager", quietly=TRUE))
install.packages("BiocManager")
# --- 3.4: Normalize and filter for your gene (RBM47) ---
# We can't use raw counts. We'll do a simple log2-transform
# of "counts-per-million" (CPM) for visualization.
# For a more robust analysis, use vst() or voom() as planned for your model.
cpm_matrix <- edgeR::cpm(count_matrix)
BiocManager::install("edgeR")
# --- 3.4: Normalize and filter for your gene (RBM47) ---
# We can't use raw counts. We'll do a simple log2-transform
# of "counts-per-million" (CPM) for visualization.
# For a more robust analysis, use vst() or voom() as planned for your model.
cpm_matrix <- edgeR::cpm(count_matrix)
log2_cpm_matrix <- log2(cpm_matrix + 1)
# The gene names (symbols) are in 'rowData'.
gene_info <- as.data.frame(rowData(se_coad))
# Find the Ensembl ID for RBM47
# (Replace 'RBM47' with any gene from your signature)
gene_of_interest <- "RBM47"
ensembl_id <- gene_info$gene_id[gene_info$gene_name == gene_of_interest]
# Get the log2-cpm expression values for just that one gene
# We use [1] in case the name maps to multiple Ensembl IDs
gene_expression <- log2_cpm_matrix[ensembl_id[1], ]
# --- 3.5: Create the final analysis data.frame ---
# We need to combine the clinical data and the expression data.
# First, create a data.frame from the gene expression
expression_df <- data.frame(
submitter_id = names(gene_expression),
expression = as.numeric(gene_expression)
)
# Now, select only the key columns from our clinical data
survival_df <- clinical_df[, c("submitter_id", "survival_time", "vital_status_numeric")]
# Merge the two data.frames by the patient ID
analysis_df <- merge(survival_df, expression_df, by = "submitter_id")
# Clean up: remove patients with no survival time
analysis_df <- analysis_df[!is.na(analysis_df$survival_time), ]
# --- 4.1: Find the optimal cutpoint ---
# This function tests all possible cutoffs and finds the one
# that gives the most significant (lowest p-value) separation.
cutpoint_object <- surv_cutpoint(
data = analysis_df,
time = "survival_time",
event = "vital_status_numeric",
variables = "expression" # The variable we're testing
)
str(analysis_df)
summary(analysis_df)
table(analysis_df$vital_status_numeric, useNA = "ifany")
# --- 3.5: (Corrected) Create the final analysis data.frame ---
# --- Part A: Get Expression Data ---
# `gene_expression` is a named vector. The `names()` are the full barcodes.
expression_df <- data.frame(
full_barcode = names(gene_expression),
expression = as.numeric(gene_expression)
)
# --- Part B: Get Survival Data ---
# `clinical_df` is the data.frame from colData(se_coad).
# The `rownames(clinical_df)` are the full barcodes that match the expression data.
survival_df <- data.frame(
full_barcode = rownames(clinical_df),
survival_time = clinical_df$survival_time,
vital_status_numeric = clinical_df$vital_status_numeric
)
# --- Part C: Merge ---
# NOW, we merge using 'full_barcode', which exists in both data frames.
analysis_df <- merge(survival_df, expression_df, by = "full_barcode")
# --- Part D: Clean up ---
# 1. Remove any patient with NA in time, status, or expression
analysis_df <- na.omit(analysis_df)
# 2. Remove any patient with a survival time of 0 or less (not valid)
analysis_df <- analysis_df[analysis_df$survival_time > 0, ]
# --- Part E: Check the data ---
# Let's run the checks again. This time you should see observations.
print("--- Checking Cleaned Data ---")
str(analysis_df)
summary(analysis_df)
print("--- Event Table (0=Alive, 1=Dead) ---")
table(analysis_df$vital_status_numeric, useNA = "ifany")
print("--- End of Check ---")
# --- 4.1: Find the optimal cutpoint ---
# This function tests all possible cutoffs and finds the one
# that gives the most significant (lowest p-value) separation.
cutpoint_object <- surv_cutpoint(
data = analysis_df,
time = "survival_time",
event = "vital_status_numeric",
variables = "expression" # The variable we're testing
)
# You can see the best cutoff value
print(cutpoint_object)
# --- 4.2: Categorize patients based on the cutpoint ---
# This adds a new column: 'High' or 'Low'
analysis_df <- surv_categorize(cutpoint_object)
# --- 5.1: Create the survival object ---
# This tells R which column is time and which is the event
surv_object <- Surv(
time = analysis_df$survival_time,
event = analysis_df$vital_status_numeric
)
# --- 5.2: Fit the survival model ---
# This fits the Kaplan-Meier model, comparing the groups
# (which we named 'expression' in step 4.2)
fit_model <- survfit(surv_object ~ expression, data = analysis_df)
# --- 5.3: Create the plot! ---
# ggsurvplot is a powerful function to make a publication-ready plot
ggsurvplot(
fit_model,
data = analysis_df,
pval = TRUE,                 # Add the log-rank p-value
conf.int = TRUE,             # Add confidence intervals
risk.table = TRUE,           # Add the "at-risk" table below the plot
legend.title = paste(gene_of_interest, "Expression"),
legend.labs = c("High", "Low"),
xlab = "Time (days)",
ylab = "Overall Survival Probability",
title = paste("Prognostic Value of", gene_of_interest, "in TCGA-COAD"),
ggtheme = theme_classic()    # Use a clean theme
)
ggsave("RBM47_KM_Survival_Plot.png", width = 8, height = 6, dpi = 300)
# --- 1. Publication-Ready Plot (KM + All Tables) ---
# We will store the plot in a variable 'g' to customize it
g <- ggsurvplot(
fit_model,
data = analysis_df,
# --- Main Plot Aesthetics ---
title = paste("Prognostic Value of", gene_of_interest, "in TCGA-COAD"),
xlab = "Time (days)",
ylab = "Overall Survival Probability",
# --- P-Value & Confidence Interval ---
pval = TRUE,
conf.int = TRUE,
# --- Legend ---
legend.title = paste(gene_of_interest, "Expression"),
legend.labs = c("High", "Low"),
# --- Risk Table ---
risk.table = TRUE,
tables.height = 0.2, # Adjust height of all tables
tables.theme = theme_cleantable(), # A clean theme for the tables
# --- NEW: Cumulative Events Table ---
cumevents = TRUE,
# --- NEW: Cumulative Censored Table ---
cumcensor = TRUE,
# --- Other Visual Tweaks ---
ggtheme = theme_bw() # A clean publication-ready theme
)
# Print the plot
print(g)
# --- 2. Cumulative Hazard Plot ---
ggsurvplot(
fit_model,
data = analysis_df,
title = paste("Cumulative Hazard by", gene_of_interest, "Expression"),
xlab = "Time (days)",
ylab = "Cumulative Hazard",
# --- The key change is this line: ---
fun = "cumhaz",
pval = TRUE,
conf.int = TRUE,
legend.title = paste(gene_of_interest, "Expression"),
legend.labs = c("High", "Low"),
ggtheme = theme_bw()
)
# --- 3. Cumulative Events Plot ---
ggsurvplot(
fit_model,
data = analysis_df,
title = paste("Cumulative Events (Deaths) by", gene_of_interest, "Expression"),
xlab = "Time (days)",
ylab = "Cumulative Number of Events",
# --- The key change is this line: ---
fun = "event",
legend.title = paste(gene_of_interest, "Expression"),
legend.labs = c("High", "Low"),
ggtheme = theme_bw()
)
# --- 1. Publication-Ready Plot (KM + All Tables) ---
# We will store the plot in a variable 'g' to customize it
g <- ggsurvplot(
fit_model,
data = analysis_df,
# --- Main Plot Aesthetics ---
title = paste("Prognostic Value of", gene_of_interest, "in TCGA-COAD"),
xlab = "Time (days)",
ylab = "Overall Survival Probability",
height  = 6
dpi = 300
# --- 1. Publication-Ready Plot (KM + All Tables) ---
# We will store the plot in a variable 'g' to customize it
g <- ggsurvplot(
fit_model,
data = analysis_df,
# --- Main Plot Aesthetics ---
title = paste("Prognostic Value of", gene_of_interest, "in TCGA-COAD"),
xlab = "Time (days)",
ylab = "Overall Survival Probability",
height  = 6,
dpi = 300,
# --- P-Value & Confidence Interval ---
pval = TRUE,
conf.int = TRUE,
# --- Legend ---
legend.title = paste(gene_of_interest, "Expression"),
legend.labs = c("High", "Low"),
# --- Risk Table ---
risk.table = TRUE,
tables.height = 0.2, # Adjust height of all tables
tables.theme = theme_cleantable(), # A clean theme for the tables
# --- NEW: Cumulative Events Table ---
cumevents = TRUE,
# --- NEW: Cumulative Censored Table ---
cumcensor = TRUE,
# --- Other Visual Tweaks ---
ggtheme = theme_bw() # A clean publication-ready theme
)
# Print the plot
print
# For RStudio plots window - set device size before plotting
options(repr.plot.height = 12, repr.plot.width = 10)  # If using Jupyter
# OR in RStudio, manually resize the Plots pane
# For saving to file
ggsave("km_plot.png", plot = g, width = 10, height = 12, dpi = 300)
# Make sure your 'gene_of_interest' variable is still set
# (If not, set it: gene_of_interest <- "RBM47")
# Define a filename based on your gene
csv_filename <- paste0(gene_of_interest, "_analysis_dataframe.csv")
# Save the data.frame as a CSV file
write.csv(
analysis_df,
file = csv_filename,
row.names = FALSE  # We don't need the R-specific row numbers
)
print(paste("Successfully saved data to:", csv_filename))
# Define a filename
summary_filename <- paste0(gene_of_interest, "_statistical_summary.txt")
# Use sink() to divert all console output to a file
sink(summary_filename)
# --- Print all the important information ---
cat("====================================================\n")
cat("          STATISTICAL SUMMARY FOR:", gene_of_interest, "\n")
cat("====================================================\n\n")
cat("--- 1. Optimal Cutpoint Object ---\n")
print(cutpoint_object)
cat("\n\n")
cat("--- 2. Survival Fit Model (Log-Rank Test) ---\n")
# This print() is what shows the p-value
print(fit_model)
cat("\n\n")
cat("--- 3. Detailed Survival Model Summary (Event Tables) ---\n")
# This summary() shows the detailed tables (n.risk, n.events, etc.)
summary(fit_model)
cat("\n\n")
cat("--- 4. Final Cleaned Data Head ---\n")
print(head(analysis_df))
# --- Stop diverting the output ---
sink()
print(paste("Successfully saved summary to:", summary_filename))
# --- 3.1: Save the survfit model object ---
model_filename <- paste0(gene_of_interest, "_survfit_model.Rds")
saveRDS(fit_model, file = model_filename)
# --- 3.2: Save the cutpoint object ---
cutpoint_filename <- paste0(gene_of_interest, "_cutpoint_object.Rds")
saveRDS(cutpoint_object, file = cutpoint_filename)
# --- 3.3: Save the final ggsurvplot list-object (optional, but good) ---
# (Assuming your plot is stored in a variable 'g' from the last step)
if (exists("g")) {
plot_obj_filename <- paste0(gene_of_interest, "_ggsurvplot_object.Rds")
saveRDS(g, file = plot_obj_filename)
}
print("Successfully saved all .Rds model files.")
